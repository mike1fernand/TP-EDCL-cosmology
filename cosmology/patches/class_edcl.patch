--- a/include/background.h
+++ b/include/background.h
@@ -123,6 +123,26 @@
   enum varconst_dependence varconst_dep; /**< dependence of the varying fundamental constants as a function of time */
   double varconst_transition_redshift; /**< redshift of transition between varied fundamental constants and normal fundamental constants in the 'varconst_instant' case*/
 
+  /** @name - EDCL / TP background-only parameters (optional) */
+  //@{
+  double alpha_R;      /**< EDCL amplitude parameter (paper: \alpha_R). */
+  double kappa_tick;   /**< Tick-law coefficient \kappa_{\rm tick}. */
+  double c4;           /**< Higher-derivative coefficient (kept for forward compatibility; unused at background level). */
+  double log10_l0;     /**< log10(\ell_0 / m) (kept for reporting; not used in the kernel-only background implementation). */
+  double l0_m;         /**< \ell_0 in meters (derived from log10_l0). */
+  double edcl_zeta;    /**< Kernel redshift scale \zeta (paper default: 0.5). */
+  double edcl_ai;      /**< Kernel lower limit a_i (paper default: 1e-4). */
+  int edcl_kernel_variant; /**< 0: exp(-z/\zeta) (late-time weighting); 1: 1-exp(-z/\zeta) (as written in one draft equation). */
+  double edcl_f_norm_target; /**< Mean-field normalization factor f_norm used to map \alpha_R -> \delta_0 (paper: 0.7542). */
+  double edcl_delta0;  /**< \delta(a=1) derived from parameters. */
+
+  /* Precomputed cumulative kernel integral J(a)=\int_{a_i}^{a} a' g(a') da' on a log-spaced grid. */
+  int edcl_n;
+  double * edcl_a;
+  double * edcl_J;
+  double edcl_I1; /**< I(a)=J(a)/a^2 evaluated at a=1 (normalization for \delta(a)=\delta0 I/I1). */
+  //@}
+
   //@}
 
 
@@ -292,6 +312,15 @@
   short has_curvature; /**< presence of global spatial curvature? */
   short has_varconst;  /**< presence of varying fundamental constants? */
 
+  /**
+   * EDCL / TP background-only modification.
+   *
+   * When enabled, the Hubble rate is rescaled at late times by
+   *   H(a) -> H(a) * (1 + \delta(a))
+   * where \delta(a) is computed from a causal kernel integral.
+   */
+  short has_edcl; /**< presence of EDCL/TP H(a) rescaling? */
+
   //@}
 
 
--- a/source/input.c
+++ b/source/input.c
@@ -3315,6 +3315,64 @@
     }
   }
 
+  /** 8.ab) EDCL / TP background-only modification (optional)
+   *
+   * Enable with: edcl_on = yes
+   * Required parameters used by the TP/EDCL patch:
+   *   - alpha_R
+   *   - kappa_tick
+   *   - c4
+   *   - log10_l0
+   * Optional kernel control (defaults follow the paper):
+   *   - edcl_zeta (default 0.5)
+   *   - edcl_ai   (default 1e-4)
+   *   - edcl_kernel = exp | 1mexp (default exp)
+   */
+  class_call(parser_read_string(pfc,"edcl_on",&string1,&flag1,errmsg),
+             errmsg,
+             errmsg);
+  if (flag1 == _TRUE_){
+    if (string_begins_with(string1,'y') || string_begins_with(string1,'Y')
+        || string_begins_with(string1,'t') || string_begins_with(string1,'T')
+        || string_begins_with(string1,'1')){
+      pba->has_edcl = _TRUE_;
+    }
+    else {
+      pba->has_edcl = _FALSE_;
+    }
+  }
+
+  if (pba->has_edcl == _TRUE_) {
+    class_read_double("alpha_R",pba->alpha_R);
+    class_read_double("kappa_tick",pba->kappa_tick);
+    class_read_double("c4",pba->c4);
+    class_read_double("log10_l0",pba->log10_l0);
+    pba->l0_m = pow(10.0,pba->log10_l0);
+
+    /* Optional kernel parameters */
+    class_read_double("edcl_zeta",pba->edcl_zeta);
+    class_read_double("edcl_ai",pba->edcl_ai);
+
+    class_call(parser_read_string(pfc,"edcl_kernel",&string1,&flag2,errmsg),
+               errmsg,
+               errmsg);
+    if (flag2 == _TRUE_) {
+      /* IMPORTANT: check '1mexp' before 'exp' because '1mexp' contains the substring 'exp'. */
+      if ((strstr(string1,"1mexp") != NULL) || (strstr(string1,"1MEXP") != NULL)) {
+        pba->edcl_kernel_variant = 1;
+      }
+      else if ((strstr(string1,"exp") != NULL) || (strstr(string1,"EXP") != NULL)) {
+        pba->edcl_kernel_variant = 0;
+      }
+      else {
+        class_stop(errmsg,"incomprehensible input '%s' for the field 'edcl_kernel' (expected 'exp' or '1mexp')",string1);
+      }
+    }
+
+    /* Precompute the z=0 amplitude used by the background rescaling. */
+    pba->edcl_delta0 = pba->alpha_R * (12.0 * pba->kappa_tick) * pba->edcl_f_norm_target;
+  }
+
   /** 8.b) If Omega scalar field (SCF) is different from 0 */
   if (pba->Omega0_scf != 0.){
 
@@ -5929,6 +5984,23 @@
   /** 9.b.3) Tuning parameter */
   pba->scf_tuning_index = 0;
 
+  /* EDCL / TP background-only modification (disabled by default). */
+  pba->has_edcl = _FALSE_;
+  pba->alpha_R = 0.0;
+  pba->kappa_tick = 1.0/12.0;
+  pba->c4 = 0.0;
+  pba->log10_l0 = -21.0;
+  pba->l0_m = pow(10.0, pba->log10_l0);
+  pba->edcl_zeta = 0.5;
+  pba->edcl_ai = 1e-4;
+  pba->edcl_kernel_variant = 0; /* 0: exp(-z/\zeta), 1: 1-exp(-z/\zeta) */
+  pba->edcl_f_norm_target = 0.7542;
+  pba->edcl_delta0 = 0.0;
+  pba->edcl_n = 0;
+  pba->edcl_a = NULL;
+  pba->edcl_J = NULL;
+  pba->edcl_I1 = 0.0;
+
   /**
    * Deafult to input_read_parameters_heating
    */
--- a/source/background.c
+++ b/source/background.c
@@ -115,6 +115,136 @@
 #include "background.h"
 
 /**
+ * EDCL / TP background-only helpers.
+ *
+ * The TP/EDCL implementation in this patch modifies the background Hubble
+ * rate by H(a) -> H(a) * (1 + delta(a)), where delta(a) is computed from
+ * a causal kernel integral (see the companion paper).
+ *
+ * For numerical efficiency we precompute a cumulative integral table
+ * J(a) = \int_{a_i}^{a} a' g(a') da'
+ * (with g(a) controlled by the 'edcl_kernel' choice) and use
+ * I(a) = J(a)/a^2 so that delta(a) \propto I(a).
+ */
+
+static double background_edcl_g_of_a(struct background *pba, double a){
+  /* z(a) = a^{-1} - 1 */
+  const double z = 1.0/a - 1.0;
+
+  /* Guard against nonsensical inputs. */
+  if (a <= 0.0) return 0.0;
+
+  if (pba->edcl_kernel_variant == 1) {
+    /* as-written variant: 1 - exp(-z/zeta) */
+    return 1.0 - exp(-z/pba->edcl_zeta);
+  }
+
+  /* default: exp(-z/zeta) (high-z suppressed) */
+  return exp(-z/pba->edcl_zeta);
+}
+
+static int background_edcl_init(struct background *pba){
+
+  /* Choose a log-spaced grid in a for the cumulative integral J(a). */
+  int i;
+  const int N = 5000;
+  const double a_min = pba->edcl_ai;
+  const double a_max = 1.0;
+
+  double lna_min, dlna;
+  double a_prev, integ_prev;
+
+  if (a_min <= 0.0 || a_min >= a_max) {
+    class_stop(pba->error_message,"EDCL: invalid edcl_ai=%g (expected 0 < edcl_ai < 1)",a_min);
+  }
+
+  if (pba->edcl_zeta <= 0.0) {
+    class_stop(pba->error_message,"EDCL: invalid edcl_zeta=%g (expected >0)",pba->edcl_zeta);
+  }
+
+  pba->edcl_n = N;
+  class_alloc(pba->edcl_a, N*sizeof(double), pba->error_message);
+  class_alloc(pba->edcl_J, N*sizeof(double), pba->error_message);
+
+  lna_min = log(a_min);
+  dlna = (log(a_max) - lna_min)/(N-1);
+
+  /* i=0 */
+  a_prev = exp(lna_min);
+  integ_prev = a_prev * background_edcl_g_of_a(pba,a_prev);
+  pba->edcl_a[0] = a_prev;
+  pba->edcl_J[0] = 0.0;
+
+  for (i=1; i<N; i++){
+    const double a = exp(lna_min + i*dlna);
+    const double integ = a * background_edcl_g_of_a(pba,a);
+
+    pba->edcl_a[i] = a;
+    pba->edcl_J[i] = pba->edcl_J[i-1] + 0.5*(integ_prev + integ)*(a - a_prev);
+
+    a_prev = a;
+    integ_prev = integ;
+  }
+
+  /* I(a) = J(a)/a^2; today a=1 so I1=J(1). */
+  pba->edcl_I1 = pba->edcl_J[N-1];
+  if (pba->edcl_I1 <= 0.0) {
+    class_stop(pba->error_message,"EDCL: kernel normalization integral I1=%g is non-positive",pba->edcl_I1);
+  }
+
+  return _SUCCESS_;
+}
+
+static int background_edcl_get_delta(struct background *pba,
+                                     double a,
+                                     double *delta,
+                                     double *ddelta_dloga){
+
+  double J;
+  double I;
+
+  /* Clamp outside the tabulated range. */
+  if (a <= pba->edcl_a[0]) {
+    J = 0.0;
+  }
+  else if (a >= pba->edcl_a[pba->edcl_n-1]) {
+    J = pba->edcl_J[pba->edcl_n-1];
+  }
+  else {
+    /* Binary search for interval [i_lo, i_hi]. */
+    int i_lo = 0;
+    int i_hi = pba->edcl_n-1;
+    while (i_hi - i_lo > 1) {
+      const int i_mid = (i_lo + i_hi)/2;
+      if (pba->edcl_a[i_mid] > a) i_hi = i_mid; else i_lo = i_mid;
+    }
+
+    /* Linear interpolation. */
+    {
+      const double a0 = pba->edcl_a[i_lo];
+      const double a1 = pba->edcl_a[i_hi];
+      const double t = (a - a0)/(a1 - a0);
+      J = pba->edcl_J[i_lo] + t*(pba->edcl_J[i_hi] - pba->edcl_J[i_lo]);
+    }
+  }
+
+  /* I(a) = J(a)/a^2. */
+  I = J/(a*a);
+
+  /* delta(a) = delta0 * I(a)/I(1). */
+  *delta = pba->edcl_delta0 * I / pba->edcl_I1;
+
+  /* dI/d ln a = g(a) - 2 I(a). */
+  {
+    const double g = background_edcl_g_of_a(pba,a);
+    const double dIdloga = g - 2.0*I;
+    *ddelta_dloga = pba->edcl_delta0 * dIdloga / pba->edcl_I1;
+  }
+
+  return _SUCCESS_;
+}
+
+/**
  * Background quantities at given redshift z.
  *
  * Evaluates all background quantities at a given value of
@@ -581,6 +711,31 @@
   /** - compute derivative of H with respect to conformal time */
   pvecback[pba->index_bg_H_prime] = - (3./2.) * (rho_tot + p_tot) * a + pba->K/a;
 
+  /** - EDCL / TP background-only rescaling (if enabled)
+      H(a) -> H(a) * (1 + delta(a)) */
+  if (pba->has_edcl == _TRUE_) {
+    double delta = 0.0, ddelta_dloga = 0.0;
+    class_call(background_edcl_get_delta(pba,
+                                        a,
+                                        &delta,
+                                        &ddelta_dloga),
+               pba->error_message,
+               pba->error_message);
+    const double H_base = pvecback[pba->index_bg_H];
+    const double Hprime_base = pvecback[pba->index_bg_H_prime];
+    const double H_new = H_base * (1.0 + delta);
+
+    /* d(delta)/d(tau) = a H d(delta)/dln a */
+    const double delta_prime = a * H_new * ddelta_dloga;
+
+    /* H' w.r.t the (modified) conformal time used by CLASS.
+       Note: changing H changes dln a/dtau by a factor (1+delta). */
+    const double Hprime_new = (1.0 + delta) * (1.0 + delta) * Hprime_base + delta_prime * H_base;
+
+    pvecback[pba->index_bg_H] = H_new;
+    pvecback[pba->index_bg_H_prime] = Hprime_new;
+  }
+
   /* Total energy density*/
   pvecback[pba->index_bg_rho_tot] = rho_tot;
 
@@ -831,6 +986,13 @@
              pba->error_message,
              pba->error_message);
 
+  /** - EDCL kernel precomputation (if enabled) */
+  if (pba->has_edcl == _TRUE_) {
+    class_call(background_edcl_init(pba),
+               pba->error_message,
+               pba->error_message);
+  }
+
   /** - integrate the background over log(a), allocate and fill the background table */
   class_call(background_solve(ppr,pba),
              pba->error_message,
@@ -897,6 +1059,18 @@
   free(pba->background_table);
   free(pba->d2background_dloga2_table);
 
+  /* EDCL kernel tables (allocated in background_init). */
+  if (pba->edcl_a != NULL) {
+    free(pba->edcl_a);
+    pba->edcl_a = NULL;
+  }
+  if (pba->edcl_J != NULL) {
+    free(pba->edcl_J);
+    pba->edcl_J = NULL;
+  }
+  pba->edcl_n = 0;
+  pba->edcl_I1 = 0.0;
+
   return _SUCCESS_;
 }
 /**
