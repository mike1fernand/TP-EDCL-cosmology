Colab: Tier‑A0 (patched CLASS background preflight)
================================================

Goal: build patched CLASS (tag v3.3.4 if available), then run the Tier‑A0 preflight script:
  cosmology/scripts/preflight_tiera_background.py

What you upload
---------------
1) Upload ONE pack zip to Colab (Files pane → Upload):
   - TP-EDCL-simulation-pack-v11.zip

What you run (ONE cell)
------
Important preflight check
-------------------------
Before applying the patch, the one‑cell runner runs:
  python3 cosmology/scripts/validate_patch.py cosmology/patches/class_edcl.patch
This prevents malformed patches from wasting your time.

-----------------
Copy‑paste the entire block below into a single Colab cell and run it.

---- BEGIN ONE CELL ----
```python
import os, re, json, glob, shutil, hashlib, subprocess, zipfile
from datetime import datetime

def run(cmd, cwd=None, log=None, check=True):
    print("\n$ " + cmd)
    p = subprocess.run(cmd, cwd=cwd, shell=True,
                       stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    print(p.stdout)
    if log:
        os.makedirs(os.path.dirname(log), exist_ok=True)
        with open(log, "w", encoding="utf-8") as f:
            f.write(p.stdout)
    if check and p.returncode != 0:
        raise RuntimeError(f"Command failed (exit {p.returncode}): {cmd}\nSee log: {log}")
    return p.stdout

def md5(path):
    h = hashlib.md5()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1<<20), b""):
            h.update(chunk)
    return h.hexdigest()

# 0) Locate pack zip (no assumptions)
zips = sorted(glob.glob("/content/TP-EDCL-simulation-pack-*.zip"))
if not zips:
    raise FileNotFoundError("Upload TP-EDCL-simulation-pack-v11.zip into /content, then rerun this cell.")
pack_zip = zips[-1]
print("Using pack zip:", pack_zip)

stamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
WORK = f"/content/edcl_run_{stamp}"
LOGS = os.path.join(WORK, "logs")
os.makedirs(LOGS, exist_ok=True)

manifest = {
    "timestamp_utc": stamp,
    "pack_zip": os.path.basename(pack_zip),
    "steps": []
}

def step(name, fn):
    print("\n" + "="*80)
    print("STEP:", name)
    print("="*80)
    rec = {"name": name, "ok": False}
    try:
        fn()
        rec["ok"] = True
    except Exception as e:
        rec["ok"] = False
        rec["error"] = str(e)
        print("\n[FAIL]", e)
        raise
    finally:
        manifest["steps"].append(rec)

# 1) System deps
def install_deps():
    run("apt-get update -qq", log=os.path.join(LOGS,"01_apt_update.log"))
    run("apt-get install -y -qq git patch build-essential gfortran python3-dev zip unzip",
        log=os.path.join(LOGS,"02_apt_install.log"))
    run("python3 -m pip -q install --upgrade pip", log=os.path.join(LOGS,"03_pip_upgrade.log"))
    run("python3 -m pip -q install numpy scipy matplotlib cython pyyaml", log=os.path.join(LOGS,"04_pip_install.log"))

step("Install dependencies", install_deps)

# 2) Unzip pack
PACKDIR = os.path.join(WORK, "pack")
os.makedirs(PACKDIR, exist_ok=True)

def unzip_pack():
    run(f"unzip -q '{pack_zip}' -d '{PACKDIR}'", log=os.path.join(LOGS,"10_unzip_pack.log"))

step("Unzip pack", unzip_pack)

roots = sorted(glob.glob(os.path.join(PACKDIR, "TP_EDCL_v*")))
if not roots:
    raise RuntimeError("Unzipped pack does not contain TP_EDCL_v* directory.")
REPO = roots[-1]
print("Pack root:", REPO)

patch_path = os.path.join(REPO, "cosmology", "patches", "class_edcl.patch")
if not os.path.exists(patch_path):
    raise RuntimeError(f"Missing class_edcl.patch at {patch_path}")
manifest["patch_md5"] = md5(patch_path)

# 3) Clone CLASS
CLASSDIR = os.path.join(WORK, "class_public")

def clone_class():
    run(f"git clone https://github.com/lesgourg/class_public.git '{CLASSDIR}'",
        log=os.path.join(LOGS,"20_git_clone_class.log"))

step("Clone CLASS", clone_class)

def fetch_tags():
    run("git fetch --tags --force", cwd=CLASSDIR, log=os.path.join(LOGS,"21_git_fetch_tags.log"))
    run("git tag -l 'v*'", cwd=CLASSDIR, log=os.path.join(LOGS,"22_git_tags_all.log"))

step("Fetch tags", fetch_tags)

# 4) Choose CLASS tag deterministically: prefer v3.3.4 if present, else highest semver tag
def parse_tag(t):
    m = re.match(r"^v(\d+)\.(\d+)(?:\.(\d+))?$", t.strip())
    if not m:
        return None
    maj, minr, patch = int(m.group(1)), int(m.group(2)), int(m.group(3) or 0)
    return (maj, minr, patch)

tags = run("git tag -l 'v*'", cwd=CLASSDIR, log=os.path.join(LOGS,"23_git_tags_all_again.log"))
tags = [t.strip() for t in tags.splitlines() if t.strip()]
semver = [(parse_tag(t), t) for t in tags]
semver = [(v,t) for (v,t) in semver if v is not None]
if not semver:
    raise RuntimeError("No semver-like tags found in CLASS repo (vMAJOR.MINOR[.PATCH]).")

preferred = [ (v,t) for (v,t) in semver if t == "v3.3.4" ]
if preferred:
    chosen = "v3.3.4"
    reason = "preferred tag v3.3.4 present (patch base)"
else:
    semver.sort()
    chosen = semver[-1][1]
    reason = "v3.3.4 not present; selected highest available semver tag"

manifest["class_tag_chosen"] = chosen
manifest["class_tag_reason"] = reason
print("Chosen CLASS tag:", chosen, "|", reason)

def checkout():
    run(f"git checkout -f {chosen}", cwd=CLASSDIR, log=os.path.join(LOGS,"30_git_checkout.log"))
    manifest["class_commit"] = run("git rev-parse HEAD", cwd=CLASSDIR, log=os.path.join(LOGS,"31_git_commit.log")).strip()
    manifest["class_describe"] = run("git describe --tags --always --dirty", cwd=CLASSDIR, log=os.path.join(LOGS,"32_git_describe.log")).strip()

step("Checkout chosen tag", checkout)

# 5) Validate + apply EDCL patch (fail-fast, no assumptions)
def apply_patch():
    # 5.a) Validate patch syntax/hunk counts (prevents 'malformed patch' surprises)
    run(f"python3 '{os.path.join(REPO,'cosmology','scripts','validate_patch.py')}' '{patch_path}'",
        cwd=REPO, log=os.path.join(LOGS,"39_validate_patch.log"))

    # 5.b) Dry-run against the checked-out CLASS tree (verifies the patch matches this tag)
    run(f"patch --dry-run -p1 -i '{patch_path}'", cwd=CLASSDIR, log=os.path.join(LOGS,"40_patch_dry_run.log"))

    # 5.c) Apply for real
    run(f"patch -p1 -i '{patch_path}'", cwd=CLASSDIR, log=os.path.join(LOGS,"41_patch_apply.log"))

    # Minimal verification marker
    run("grep -R \"has_edcl\" -n include/background.h | head -n 20", cwd=CLASSDIR,
        log=os.path.join(LOGS,"42_patch_verify.log"))

step("Validate + apply EDCL patch", apply_patch)

# 6) Build CLASS + classy
def build():
    run("make -j2", cwd=CLASSDIR, log=os.path.join(LOGS,"50_make.log"))
    run("make classy", cwd=CLASSDIR, log=os.path.join(LOGS,"51_make_classy.log"))

step("Build CLASS + classy", build)

# 7) Run Tier-A0 preflight (smoke + figure + Track0 compare)
def run_preflight():
    outdir = os.path.join(REPO, "cosmology", "paper_artifacts")
    if os.path.exists(outdir):
        shutil.rmtree(outdir)
    os.makedirs(outdir, exist_ok=True)

    run(f"python3 '{os.path.join(REPO,'cosmology','scripts','smoke_test_classy_edcl.py')}' "
        f"--class-path '{CLASSDIR}'",
        cwd=REPO, log=os.path.join(LOGS,"60_smoke_test.log"))

    run(f"python3 '{os.path.join(REPO,'cosmology','scripts','preflight_tiera_background.py')}' "
        f"--class-path '{CLASSDIR}' "
        f"--alpha_R 0.11824 --log10_l0 -20.908 "
        f"--kappa_tick 0.08333333333333333 --c4 0.06 "
        f"--zeta 0.5 --kernel exp",
        cwd=REPO, log=os.path.join(LOGS,"61_preflight.log"))

    # Verify expected outputs exist
    expected = [
        os.path.join(outdir, "preflight_report.txt"),
        os.path.join(outdir, "fig_hubble_ratio_from_class.png"),
        os.path.join(outdir, "hubble_ratio_from_class.csv"),
    ]
    for p in expected:
        if not os.path.exists(p):
            run(f"ls -la '{outdir}'", cwd=REPO, log=os.path.join(LOGS,"62_list_outdir.log"), check=False)
            raise RuntimeError(f"Missing expected artifact: {p}")

step("Run Tier-A0 preflight", run_preflight)

# 8) Bundle outputs + logs
bundle = "/content/edcl_bundle.zip"
with open(os.path.join(WORK, "manifest.json"), "w", encoding="utf-8") as f:
    json.dump(manifest, f, indent=2)

if os.path.exists(bundle):
    os.remove(bundle)

with zipfile.ZipFile(bundle, "w", compression=zipfile.ZIP_DEFLATED) as z:
    z.write(os.path.join(WORK, "manifest.json"), arcname="manifest.json")
    for dp, dn, fn in os.walk(LOGS):
        for name in fn:
            full = os.path.join(dp, name)
            rel = os.path.relpath(full, WORK)
            z.write(full, arcname=rel)
    # Include artifacts
    art = os.path.join(REPO, "cosmology", "paper_artifacts")
    for dp, dn, fn in os.walk(art):
        for name in fn:
            full = os.path.join(dp, name)
            rel = os.path.relpath(full, REPO)
            z.write(full, arcname=os.path.join("pack", rel))

print("\nCreated:", bundle)
print("Manifest summary:")
print(json.dumps({k:manifest[k] for k in ["class_tag_chosen","class_commit","class_describe","class_tag_reason","patch_md5"]}, indent=2))

from google.colab import files
files.download(bundle)
```
---- END ONE CELL ----

What you should download afterwards
----------------------------------
The cell will download: `edcl_bundle.zip`

Inside it you will find:
- `manifest.json` (records tag/commit + patch md5)
- `logs/*.log` (all build/run logs)
- `pack/cosmology/paper_artifacts/*` (the key outputs for Tier‑A0)

If anything fails, upload `edcl_bundle.zip` back into chat and I can pinpoint the exact failure stage.
